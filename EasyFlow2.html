<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FruityAlfred Software â€“ EasyFlow</title>
  <style>
    :root {
      --bg: #f7f7fb;
      --panel: #ffffff;
      --border: #dadde6;
      --text: #222;
      --muted: #667085;
      --primary: #2563eb;
      --primary-600: #1d4ed8;
      --success: #10b981;
      --danger: #ef4444;
      --warn: #f59e0b;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--text); background: var(--bg);
      display: flex; flex-direction: column; height: 100vh;
    }
    .toolbar, .columns-bar, .properties { background: var(--panel); border: 1px solid var(--border); }
    .toolbar { display:flex; flex-wrap: wrap; gap: 8px; align-items:center; padding: 10px 12px; border-left: 0; border-right: 0; }
    .title { font-weight: 700; margin-right: 8px; }
    .group { display:flex; gap: 8px; align-items: center; }
    .divider { width:1px; height:28px; background: var(--border); margin: 0 8px; }
    button, select, input[type="number"], input[type="text"] {
      height: 32px; border-radius: 8px; border: 1px solid var(--border);
      background: #f3f4f6; color: #111; padding: 0 10px; font-size: 13px;
    }
    button { cursor: pointer; }
    button.primary { background: var(--primary); color: #fff; border-color: var(--primary-600); }
    button.primary:hover { background: var(--primary-600); }
    button.success { background: var(--success); color:#fff; border-color: #0d966c; }
    button.warn { background: var(--warn); color:#111; }
    button.gray { background: #e5e7eb; }
    button[disabled] { opacity: .6; cursor: not-allowed; }
    .columns-bar { padding: 8px 12px; border-left: 0; border-right: 0; display:flex; gap: 14px; align-items:center; flex-wrap: wrap; }
    .col-item { display:flex; gap:6px; align-items:center; padding: 4px 6px; border:1px dashed var(--border); border-radius:8px; }
    .col-item input[type="text"] { width: 120px; }
    .col-item input[type="number"] { width: 60px; }
    .canvas-wrap { position: relative; flex: 1; min-height: 0; }
    #columnsBg { position:absolute; inset:0; display:flex; z-index:1; pointer-events:none; }
    #columnHandles { position:absolute; inset:0; z-index:20; pointer-events:none; }
    .col-bg { position:relative; border-right: 1px solid #cfd4e0; display:flex; align-items:flex-start; justify-content:center; padding-top:8px; }
    .col-bg > span { font-size:12px; color:#555; background:#fff; padding: 2px 6px; border-radius: 6px; box-shadow: 0 1px 2px rgba(0,0,0,.06); }
    .col-resizer { position:absolute; top:0; width:10px; height:100%; cursor:col-resize; z-index:50; pointer-events:auto; }
    .col-resizer::after { content:""; position:absolute; top:0; bottom:0; left:50%; width:2px; transform:translateX(-50%); background: rgba(0,0,0,.18); border-radius:1px; }
    #canvas { position:absolute; inset:0; width:100%; height:100%; z-index:10; }
    .hint { position:absolute; top:12px; left:12px; background:#dbeafe; color:#1e40af; border:1px solid #93c5fd; padding:6px 10px; border-radius:8px; font-size:12px; z-index:20; }
    .status { position:absolute; top:12px; right:12px; background:#f3f4f6; color:#374151; border:1px solid var(--border); padding:6px 10px; border-radius:8px; font-size:12px; z-index:20; }
    .properties { padding: 10px 12px; border-left: 0; border-right: 0; }
    .prop-grid { display:flex; gap:10px; align-items:center; flex-wrap: wrap; }
    .prop-grid input[type="number"] { width: 70px; }
    .badge { display:inline-flex; align-items:center; gap:6px; height:28px; padding: 0 10px; border-radius:999px; font-size:12px; border:1px solid var(--border); background:#fff; }
    .sr-only { position:absolute; left:-10000px; top:auto; width:1px; height:1px; overflow:hidden; }

    /* AI Import Bar */
    .ai-bar{display:none;flex-wrap:wrap;gap:8px;align-items:flex-start;padding:10px 12px;border:1px solid var(--border);border-left:0;border-right:0;background:var(--panel)}
    .ai-bar textarea{flex:1;min-width:280px;height:80px;padding:8px;border-radius:8px;border:1px solid var(--border);font-family:inherit;font-size:13px}
    .ai-bar input[type="password"], .ai-bar select{height:32px;border-radius:8px;border:1px solid var(--border);padding:0 10px}
    .ai-bar .muted{color:var(--muted);font-size:12px}

    /* Icon Picker */
    .modal{position:fixed; inset:0; background:rgba(0,0,0,.3); display:none; align-items:center; justify-content:center; z-index:100}
    .modal .panel{background:#fff; border:1px solid var(--border); border-radius:10px; width:min(900px,90vw); max-height:80vh; display:flex; flex-direction:column}
    .modal .head{display:flex; gap:8px; align-items:center; padding:10px; border-bottom:1px solid var(--border)}
    .modal .head input, .modal .head select{height:32px}
    .modal .grid{padding:10px; overflow:auto; display:grid; grid-template-columns:repeat(auto-fill, minmax(80px,1fr)); gap:10px}
    .modal .cell{display:flex; flex-direction:column; align-items:center; gap:6px; padding:8px; border:1px solid var(--border); border-radius:8px; cursor:pointer}
    .modal .cell:hover{background:#f8fafc}
    .icon-svg{width:32px; height:32px}
  </style>
</head>
<body>
  <div class="toolbar" id="toolbar">
    <span class="title">EasyFlow Canvas</span>

    <div class="group" id="elementButtons"></div>

    <div class="divider"></div>

    <div class="group">
      <button id="connectBtn" class="gray" data-translate-key="connect" data-translate-key-title="connectTitle">Verbinden</button>
      <select id="connectionMode">
        <option value="auto">Auto</option>
        <option value="horizontal">Horizontal</option>
        <option value="vertical">Vertical</option>
      </select>
    </div>

    <div class="divider"></div>

    <div class="group">
      <button id="gridToggle" class="gray" title="Grid on/off">Grid</button>
      <button id="guidesToggle" class="gray" title="Guides on/off">Guides</button>
      <label class="badge">Grid Size <input id="gridSize" type="number" min="10" max="50" value="20"></label>
    </div>

    <div class="divider"></div>

    <div class="group">
      <button id="copyBtn" class="gray" title="Copy (Ctrl+C)">Copy</button>
      <button id="pasteBtn" class="gray" title="Paste (Ctrl+V)" disabled>Paste</button>
    </div>

    <div class="divider"></div>

  <div class="group">
      <button id="saveBtn" class="warn" title="Save (Ctrl+S)">Save</button>
      <button id="loadBtn" class="warn">Load</button>
      <input id="fileInput" class="sr-only" type="file" accept=".json" />
      <button id="exportSvgBtn" class="success">Export SVG</button>
      <button id="resetBtn" class="danger" data-translate-key="reset" data-translate-key-title="resetTitle">Reset</button>
  </div>

  <div class="group">
      <button id="addImgBtn" class="gray" data-translate-key="addImage" title="Add Image">+ Image</button>
      <input id="imgInput" class="sr-only" type="file" accept="image/*" />
      <button id="addIconBtn" class="gray" data-translate-key="addIcon" title="Add Icon">+ Icon</button>
  </div>

    <div class="group">
      <label class="badge"><input id="aiEnable" type="checkbox"> <span data-translate-key="aiAssistant">AI-Assistent</span></label>
    </div>
        
    <div class="divider"></div>
        
    <div class="group">
      <label class="badge" style="gap: 4px;">
        <span data-translate-key="language">Sprache</span>:
        <select id="langSwitch" style="border:0; background:transparent; height: auto; padding: 0;">
          <option value="de">DE</option>
          <option value="en">EN</option>
        </select>
      </label>
    </div>

    <div class="group" style="color:#6b7280;font-size:12px;" data-translate-key="hintText">ðŸ’¡ Ctrl+C/V Copy â€¢ Delete lÃ¶scht â€¢ Verbinden bleibt aktiv</div>
  </div>

  <div class="ai-bar" id="aiBar">
    <textarea id="aiInput" data-translate-key-placeholder="aiInputPlaceholder"></textarea>
    <div style="display:flex;flex-direction:column;gap:8px;min-width:260px">
      <input id="aiKey" type="password" data-translate-key-placeholder="apiKeyPlaceholder">
      <div style="display:flex;gap:8px;align-items:center">
        <select id="aiModel">
          <option value="gpt-4o-mini">gpt-4o-mini <span data-translate-key="recommended">(empfohlen)</span></option>
          <option value="gpt-4o">gpt-4o</option>
        </select>
        <button id="aiGenerateBtn" class="primary" data-translate-key="generateFromAI">Flow aus KI</button>
        <button id="aiSampleBtn" class="gray" data-translate-key="example" data-translate-key-title="loadExample">Beispiel</button>
      </div>
      <div class="muted" data-translate-key="proxyWarning">FÃ¼r Produktion bitte Proxy nutzen â€“ Key niemals im Client ausliefern.</div>
    </div>
  </div>

  <div class="columns-bar" id="columnsBar"></div>

  <div class="canvas-wrap">
    <div id="connectHint" class="hint" style="display:none;"></div>
    <div id="columnsBg"></div>
    <div id="columnHandles"></div>
    <svg id="canvas" xmlns="http://www.w3.org/2000/svg">
      </svg>
  </div>

  <div class="properties" id="props" style="display:none;"></div>

  <!-- Icon Picker Modal -->
  <div class="modal" id="iconModal" aria-hidden="true">
    <div class="panel">
      <div class="head">
        <select id="iconLibrary">
          <option value="lucide">Lucide</option>
          <option value="bootstrap">Bootstrap Icons</option>
        </select>
        <input id="iconSearch" type="text" placeholder="Search..." style="flex:1;">
        <button id="iconClose">âœ•</button>
      </div>
      <div class="grid" id="iconGrid"></div>
    </div>
  </div>

  <script>
    // ======= i18n & Translations =======
    const translations = {
      de: {
        connect: 'Verbinden',
        connectTitle: 'Verbinden an/aus',
        aiAssistant: 'AI-Assistent',
        language: 'Sprache',
        hintText: 'ðŸ’¡ Ctrl+C/V Copy â€¢ Delete lÃ¶scht â€¢ Verbinden bleibt aktiv',
        aiInputPlaceholder: 'Beschreibe Organisation/Prozesseâ€¦\nBeispiel: User stellt Ticket â†’ 1st Level klassifiziert â†’ Entscheidung: Incident vs. Service Request â†’ Genehmigung â†’ Umsetzung â†’ Abschluss & Review',
        apiKeyPlaceholder: 'OpenAI API Key (nur Test â€“ im Browser UNSICHER)',
        recommended: '(empfohlen)',
        generateFromAI: 'Flow aus KI',
        loadExample: 'Beispiel laden',
        example: 'Beispiel',
        proxyWarning: 'FÃ¼r Produktion bitte Proxy nutzen â€“ Key niemals im Client ausliefern.',
        columns: 'Spalten:',
        statusDefault: 'Raster/Hilfslinien steuerbar â€¢ SVG-Export',
        propTextPlaceholder: 'Text eingeben...',
        colAnfrage: 'Anfrage',
        colBewertung: 'Bewertung',
        colGenehmigung: 'Genehmigung',
        colUmsetzung: 'Umsetzung',
        elStart: 'Start/Ende',
        elProcess: 'Prozess',
        elDecision: 'Entscheidung',
        elDocument: 'Dokument',
        elDatabase: 'Datenbank',
        elManual: 'Manuell',
        elWait: 'Wartezeit',
        elImage: 'Bild',
        reset: 'Reset',
        resetTitle: 'Alles zurÃ¼cksetzen',
        confirmReset: 'MÃ¶chten Sie wirklich die gesamte ArbeitsflÃ¤che zurÃ¼cksetzen? Alle Ã„nderungen gehen verloren.',
        elConnector: 'Verbinder',
        connectHintTarget: 'Ziel-Element wÃ¤hlen (Modus bleibt aktiv)',
        connectHintStart: 'Start-Element wÃ¤hlen',
        alertInvalidFile: 'UngÃ¼ltige Datei',
        alertLoadError: 'Fehler beim Laden',
        alertAINoInput: 'Bitte eine Organisationsbeschreibung eingeben.',
        alertAINoKey: 'Bitte einen OpenAI API Key eingeben (nur zu Testzwecken im Browser).',
        alertGenericError: 'Fehler: ',
        statusAISending: 'Sende an OpenAIâ€¦',
        statusAILoaded: 'Flow geladen.',
        statusAIFailed: 'Fehler beim Laden.',
        defaultColName: 'Spalte',
        defaultNodeName: 'Knoten',
        equalize: 'Alle gleich',
        addColumn: 'Spalte hinzufÃ¼gen',
        visible: 'Sichtbar',
        addImage: 'Bild hinzufÃ¼gen',
        addIcon: 'Icon hinzufÃ¼gen',
        aiSampleText: `ITIL-angelehnter Request Flow:\n- Nutzer stellt Service Request im Portal ein (Start)\n- 1st Level klassifiziert und prÃ¼ft\n- Entscheidung: Incident oder Service Request?\n  - Wenn Incident: Incident-Process, Workaround, Escalation, Abschluss\n  - Wenn Service Request: Genehmigung durch Kostenstellenleiter\n- Umsetzung durch Field IT\n- Dokumentation & Abschlussbericht\n- Knowledge Update & Review (Ende)`,
        aiPrompt: `Erzeuge *ausschlieÃŸlich* valides JSON, keine ErklÃ¤rtexte, keine Markdown-CodeblÃ¶cke. Schema:\n{\n  \"version\": \"1.0\",\n  \"columns\": [ { \"id\": number, \"name\": string, \"flex\": number, \"color\": string } ],\n  \"elements\": [\n    { \"id\": string (oder leer), \"type\": \"start\"|\"process\"|\"decision\"|\"document\"|\"database\"|\"manual\"|\"wait\"|\"connector\",\n      \"text\": string,\n      \"lane\": string (Spaltenname),\n      \"width\"?: number, \"height\"?: number,\n      \"x\"?: number, \"y\"?: number\n    }\n  ],\n  \"connections\": [ { \"from\": string, \"to\": string, \"mode\"?: \"auto\"|\"horizontal\"|\"vertical\" } ]\n}\nRegeln: 1) IDs, wenn leer, einfach generisch lassen (wir vergeben sie). 2) *Kein* Freitext auÃŸerhalb des JSON. 3) Lane-Namen mÃ¼ssen den Spaltennamen entsprechen. 4) Wenn Position (x,y) fehlt: nur lane setzen.\n\nOrganisation:\n{orgText}`
      },
      en: {
        connect: 'Connect',
        connectTitle: 'Toggle Connection Mode',
        aiAssistant: 'AI Assistant',
        language: 'Language',
        hintText: 'ðŸ’¡ Ctrl+C/V Copy â€¢ Del deletes â€¢ Connect mode stays active',
        aiInputPlaceholder: 'Describe organization/processesâ€¦\nExample: User creates ticket â†’ 1st Level classifies â†’ Decision: Incident vs. Service Request â†’ Approval â†’ Implementation â†’ Closure & Review',
        apiKeyPlaceholder: 'OpenAI API Key (test only - INSECURE in browser)',
        recommended: '(recommended)',
        generateFromAI: 'Generate from AI',
        loadExample: 'Load Example',
        example: 'Example',
        proxyWarning: 'For production, use a proxy â€“ never expose keys on the client.',
        columns: 'Columns:',
        statusDefault: 'Grid/Guides controllable â€¢ SVG Export',
        propTextPlaceholder: 'Enter text...',
        colAnfrage: 'Request',
        colBewertung: 'Triage',
        colGenehmigung: 'Approval',
        colUmsetzung: 'Implementation',
        elStart: 'Start/End',
        elProcess: 'Process',
        elDecision: 'Decision',
        elDocument: 'Document',
        elDatabase: 'Database',
        elManual: 'Manual Input',
        elWait: 'Delay',
        elImage: 'Image',
        reset: 'Reset',
        resetTitle: 'Reset entire canvas',
        confirmReset: 'Are you sure you want to reset the entire canvas? All changes will be lost.',
        elConnector: 'Connector',
        connectHintTarget: 'Select target element (mode remains active)',
        connectHintStart: 'Select starting element',
        alertInvalidFile: 'Invalid file',
        alertLoadError: 'Error while loading',
        alertAINoInput: 'Please enter an organization description.',
        alertAINoKey: 'Please enter an OpenAI API Key (for browser testing only).',
        alertGenericError: 'Error: ',
        statusAISending: 'Sending to OpenAIâ€¦',
        statusAILoaded: 'Flow loaded.',
        statusAIFailed: 'Error during loading.',
        defaultColName: 'Column',
        defaultNodeName: 'Node',
        equalize: 'Equalize',
        addColumn: 'Add Column',
        visible: 'Visible',
        addImage: 'Add Image',
        addIcon: 'Add Icon',
        aiSampleText: `ITIL-inspired Request Flow:\n- User submits a Service Request in the portal (Start)\n- 1st Level classifies and checks it\n- Decision: Is it an Incident or a Service Request?\n  - If Incident: Incident Process, Workaround, Escalation, Closure\n  - If Service Request: Approval by cost center manager\n- Implementation by Field IT\n- Documentation & Final Report\n- Knowledge Update & Review (End)`,
        aiPrompt: `Generate *only* valid JSON, no explanatory text, no markdown code blocks. Schema:\n{\n  \"version\": \"1.0\",\n  \"columns\": [ { \"id\": number, \"name\": string, \"flex\": number, \"color\": string } ],\n  \"elements\": [\n    { \"id\": string (or empty), \"type\": \"start\"|\"process\"|\"decision\"|\"document\"|\"database\"|\"manual\"|\"wait\"|\"connector\",\n      \"text\": string,\n      \"lane\": string (column name),\n      \"width\"?: number, \"height\"?: number,\n      \"x\"?: number, \"y\"?: number\n    }\n  ],\n  \"connections\": [ { \"from\": string, \"to\": string, \"mode\"?: \"auto\"|\"horizontal\"|\"vertical\" } ]\n}\nRules: 1) If IDs are empty, just leave them (we assign them). 2) *No* free text outside the JSON. 3) Lane names must match the column names. 4) If position (x,y) is missing: just set the lane.\n\nOrganization:\n{orgText}`
      }
    };
    
    // ======= State =======
    const state = {
      lang: 'de', // Current language
      elements: [],
      connections: [],
      selectedElement: null,
      selectedElements: [],
      copiedElement: null,
      isDragging: false,
      isDraggingGroup: false,
      isResizing: false,
      resizeHandle: null,
      dragStart: { x:0, y:0 },
      groupStartPos: null, // Map(id -> {x,y}) during group drag
      isMarquee: false,
      marqueeRect: null, // {x,y,w,h}
      isConnecting: false,
      connectionStart: null,
      connectionMode: 'auto',
      showGrid: false,
      gridSize: 20,
      showGuides: true,
      guideLines: [],
      columns: [
        { id: 1, nameKey: 'colAnfrage', customName: null, flex: 1, color: '#f0f9ff' },
        { id: 2, nameKey: 'colBewertung', customName: null, flex: 1, color: '#f0fdf4' },
        { id: 3, nameKey: 'colGenehmigung', customName: null, flex: 1, color: '#fffbeb' },
        { id: 4, nameKey: 'colUmsetzung', customName: null, flex: 1, color: '#fef2f2' }
      ],
      currentFont: 'Arial',
      currentFontSize: 12,
      currentColor: '#3b82f6',
      aiEnabled: false,
      columnsBaseTotalFlex: null,
    };

    // Drag state for column resizing
    let colDrag = null; // { leftIdx, rightIdx, startX, bgWidth, totalFlex, leftStartFlex, rightStartFlex }

    const elementTypes = {
      start:     { nameKey: 'elStart',     shape: 'oval',     color: '#10b981' },
      process:   { nameKey: 'elProcess',   shape: 'rectangle',color: '#3b82f6' },
      decision:  { nameKey: 'elDecision',  shape:'diamond',  color: '#f59e0b' },
      document:  { nameKey: 'elDocument',  shape: 'document', color: '#8b5cf6' },
      database:  { nameKey: 'elDatabase',  shape: 'database', color: '#06b6d4' },
      manual:    { nameKey: 'elManual',    shape: 'trapezoid',color: '#ef4444' },
      wait:      { nameKey: 'elWait',      shape: 'delay',    color: '#6b7280' },
      connector: { nameKey: 'elConnector', shape: 'circle',   color: '#1f2937' },
      image:     { nameKey: 'elImage',     shape: 'image',    color: '#ffffff' }
    };

    const fonts = ['Arial','Helvetica','Times New Roman','Courier New','Verdana','Georgia'];

    // ======= Utils =======
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));
    const NS = 'http://www.w3.org/2000/svg';
    const genId = () => Math.random().toString(36).slice(2,11);
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
    const i18n = (key, fallback = '') => translations[state.lang]?.[key] || fallback || key;

    function snapToGrid(v){ return state.showGrid ? Math.round(v / state.gridSize) * state.gridSize : v; }

    function escapeHtml(str){
      if (typeof str !== 'string') return '';
      return str.replace(/[&<>"']/g, function(ch){
        return ({ '&':'&amp;', '<':'&lt;', '>':'&gt;', '"':'&quot;', "'":'&#039;' })[ch];
      });
    }

    function getColumnWidth(columnId){
      const visible = state.columns.filter(c => c.flex > 0);
      const total = visible.reduce((s,c)=>s+c.flex,0) || 1;
      const col = state.columns.find(c=>c.id===columnId);
      if (!col || col.flex===0) return 0;
      return (col.flex/total) * 100;
    }

    function getConnectionPoints(el){
      const w = el.width ?? 120; const h = el.height ?? 60;
      return {
        top:    { x: el.x + w/2, y: el.y },
        bottom: { x: el.x + w/2, y: el.y + h },
        left:   { x: el.x,       y: el.y + h/2 },
        right:  { x: el.x + w,   y: el.y + h/2 },
      };
    }

    function generateGuideLines(dragged){
      if (!state.showGuides || !dragged) return [];
      const guides = []; const thr = 5;
      for (const el of state.elements){
        if (el.id === dragged.id) continue;
        const ew = el.width || 120, eh = el.height || 60;
        const dw = dragged.width || 120, dh = dragged.height || 60;
        // vertical
        if (Math.abs(el.x - dragged.x) < thr) guides.push({type:'vertical', position: el.x, color:'#ff6b6b'});
        if (Math.abs((el.x + ew/2) - (dragged.x + dw/2)) < thr) guides.push({type:'vertical', position: el.x + ew/2, color:'#ff6b6b'});
        if (Math.abs((el.x + ew) - (dragged.x + dw)) < thr) guides.push({type:'vertical', position: el.x + ew, color:'#ff6b6b'});
        // horizontal
        if (Math.abs(el.y - dragged.y) < thr) guides.push({type:'horizontal', position: el.y, color:'#ff6b6b'});
        if (Math.abs((el.y + eh/2) - (dragged.y + dh/2)) < thr) guides.push({type:'horizontal', position: el.y + eh/2, color:'#ff6b6b'});
        if (Math.abs((el.y + eh) - (dragged.y + dh)) < thr) guides.push({type:'horizontal', position: el.y + eh, color:'#ff6b6b'});
      }
      return guides;
    }

    // ======= Rendering =======
    function renderElementButtons(){
      const wrap = $('#elementButtons');
      wrap.innerHTML = '';
      for (const [type, cfg] of Object.entries(elementTypes)){
        const btn = document.createElement('button');
        const name = i18n(cfg.nameKey);
        btn.textContent = '+ ' + name;
        btn.style.background = cfg.color; btn.style.color = '#fff'; btn.title = name;
        btn.addEventListener('click', ()=> addElement(type));
        wrap.appendChild(btn);
      }
    }

    function renderColumnsBar(){
      const bar = $('#columnsBar');
      bar.innerHTML = `<span style="font-weight:600;">${i18n('columns')}</span>`;
      for (const col of state.columns){
        const item = document.createElement('div');
        item.className = 'col-item';
        const displayName = col.customName ?? i18n(col.nameKey);
        item.innerHTML = `
          <input type="text" value="${escapeHtml(displayName)}">
          <input type="color" value="${col.color}" style="width:26px;height:26px;">
        `;
        const [nameInput, colorInput] = item.querySelectorAll('input');
        nameInput.addEventListener('input', e=>{ col.customName = e.target.value; renderColumnsBg(); });
        colorInput.addEventListener('input', e=>{ col.color = e.target.value; renderColumnsBg(); });
        bar.appendChild(item);
      }
      const eqBtn = document.createElement('button');
      eqBtn.className = 'gray';
      eqBtn.textContent = i18n('equalize');
      eqBtn.title = i18n('equalize');
      eqBtn.addEventListener('click', equalizeColumns);
      bar.appendChild(eqBtn);
    }

    function ensureFlexBase(){
      const vis = state.columns.filter(c=>c.flex>0);
      const sum = vis.reduce((s,c)=>s+c.flex,0);
      if (!state.columnsBaseTotalFlex || state.columnsBaseTotalFlex <= 0){
        state.columnsBaseTotalFlex = sum || vis.length || 1;
      }
    }

    function renderColumnsBg(){
      const bg = $('#columnsBg');
      bg.innerHTML = '';
      const handles = $('#columnHandles');
      if (handles) handles.innerHTML = '';
      const visible = state.columns.map((c,idx)=> ({...c, _idx: idx})).filter(c=>c.flex>0);
      const sumFlex = visible.reduce((s,c)=> s + (Number(c.flex)||0), 0);
      const baseTotal = (sumFlex > 1 + 1e-6) ? sumFlex : 1; // adapt: keep free space if sum <= 1

      // Draw columns
      const widths = [];
      for (const col of visible){
        const w = (col.flex/baseTotal)*100;
        widths.push(w);
        const div = document.createElement('div');
        div.className = 'col-bg';
        div.style.width = w + '%';
        div.style.background = col.color;
        const badge = document.createElement('span');
        badge.textContent = col.customName ?? i18n(col.nameKey);
        div.appendChild(badge);
        bg.appendChild(div);
      }

      // Add a resizer at the right edge of each column (independent resize)
      if (handles){
        let cum = 0;
        for (let vi = 0; vi < visible.length; vi++){
          cum += widths[vi] || 0;
          const idx = visible[vi]._idx;
          const handle = document.createElement('div');
          handle.className = 'col-resizer';
          handle.title = 'Resize column';
          handle.style.left = `calc(${cum}% - 5px)`;
          handle.style.right = 'auto';
          handle.style.pointerEvents = 'auto';
          handle.addEventListener('pointerdown', (e)=>{
            e.preventDefault();
            const rect = bg.getBoundingClientRect();
            const othersSum = state.columns
              .filter((c,ii)=> c.flex>0 && ii!==idx)
              .reduce((s,c)=> s + c.flex, 0);
            colDrag = {
              targetIdx: idx,
              startX: e.clientX,
              bgWidth: rect.width,
              baseTotal: baseTotal,
              startFlex: state.columns[idx].flex,
              othersSum,
            };
            document.body.style.userSelect = 'none';
            window.addEventListener('pointermove', onColResizeMove);
            window.addEventListener('pointerup', onColResizeEnd, { once: true });
          });
          handle.addEventListener('dblclick', equalizeColumns);
          handles.appendChild(handle);
        }
      }
    }

    function onColResizeMove(e){
      if (!colDrag) return;
      const dx = e.clientX - colDrag.startX;
      if (colDrag.bgWidth <= 0) return;
      const deltaPct = (dx / colDrag.bgWidth) * 100;
      const denom = colDrag.baseTotal || 1;
      const minPct = 5; // minimal 5% visual width
      const minFlex = (minPct/100) * denom;
      const deltaFlex = (deltaPct/100) * denom;

      let newFlex = colDrag.startFlex + deltaFlex;
      const maxFlex = Math.max(minFlex, (denom - (colDrag.othersSum ?? 0)));
      newFlex = Math.max(minFlex, Math.min(maxFlex, newFlex));
      state.columns[colDrag.targetIdx].flex = newFlex;
      renderColumnsBg();
    }

    function onColResizeEnd(){
      document.body.style.userSelect = '';
      window.removeEventListener('pointermove', onColResizeMove);
      colDrag = null;
      renderColumnsBar();
    }

    // Make available globally so renderColumnsBar can bind before any rendering
    function equalizeColumns(){
      const vis = state.columns.filter(c=>c.flex>0);
      if (!vis.length) return;
      const share = 1 / vis.length;
      for (const c of vis) c.flex = share;
      renderColumnsBg();
      renderColumnsBar();
    }

    function svgEl(tag, attrs={}, children=[]) {
      const el = document.createElementNS(NS, tag);
      for (const [k,v] of Object.entries(attrs)){
        if (v == null) continue;
        el.setAttribute(k, String(v));
      }
      for (const c of children) el.appendChild(c);
      return el;
    }

    // Convert an SVG markup string to a PNG data URL at the requested size
    function svgToPngDataUrl(svgStr, w, h){
      return new Promise((resolve)=>{
        try{
          const blob = new Blob([String(svgStr)], { type:'image/svg+xml;charset=utf-8' });
          const url = URL.createObjectURL(blob);
          const img = new Image();
          img.onload = ()=>{
            const ratio = window.devicePixelRatio || 1;
            const canvas = document.createElement('canvas');
            canvas.width = Math.max(1, Math.round(w * ratio));
            canvas.height = Math.max(1, Math.round(h * ratio));
            const ctx = canvas.getContext('2d');
            ctx.scale(ratio, ratio);
            ctx.clearRect(0,0,w,h);
            ctx.drawImage(img, 0, 0, w, h);
            const png = canvas.toDataURL('image/png');
            URL.revokeObjectURL(url);
            resolve(png);
          };
          img.onerror = ()=>{ URL.revokeObjectURL(url); resolve(null); };
          img.src = url;
        }catch(e){ resolve(null); }
      });
    }

    // Render SVG markup inline as vector paths into a given group (immediate visual)
    function renderSvgMarkupAsPaths(g, svgStr, w, h){
      try{
        const parser = new DOMParser();
        const doc = parser.parseFromString(String(svgStr), 'image/svg+xml');
        const root = doc.documentElement; if (!root || root.nodeName.toLowerCase() !== 'svg') return false;
        const vb = root.getAttribute('viewBox') || '0 0 24 24';
        const parts = vb.split(' ').map(Number); const vbw = parts[2]||24, vbh = parts[3]||24;
        const sx = w/(vbw||24), sy = h/(vbh||24);
        const wrap = svgEl('g', { transform:`scale(${sx} ${sy})` });
        const shapes = root.querySelectorAll('path,rect,circle,ellipse,polygon,polyline,line');
        shapes.forEach(node=>{
          const tag = node.tagName.toLowerCase();
          const attrs = Object.fromEntries(Array.from(node.attributes).map(a=>[a.name,a.value]));
          const n = svgEl(tag, attrs);
          if (n.getAttribute('fill') === 'currentColor') n.setAttribute('fill', '#374151');
          if (n.getAttribute('stroke') === 'currentColor') n.setAttribute('stroke', '#374151');
          wrap.appendChild(n);
        });
        g.appendChild(wrap); return true;
      }catch(e){ return false; }
    }

    // Name converters for Lucide (PascalCase <-> kebab-case)
    function toKebabCase(name){
      if (!name) return '';
      return String(name)
        .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
        .replace(/\s+/g,'-')
        .toLowerCase();
    }
    function toPascalCase(name){
      if (!name) return '';
      const s = String(name).replace(/[-_\s]+(.)?/g, (_,c)=> c? c.toUpperCase(): '')
                            .replace(/^(.)/, (m)=> m.toUpperCase());
      return s; // e.g. book-open -> BookOpen
    }

    // Try to obtain Lucide SVG by temporarily using lucide.createIcons on a hidden node
    function getLucideSvg(name){
      try{
        if (!window.lucide || typeof window.lucide.createIcons !== 'function') return null;
        const host = document.createElement('div');
        host.style.position='absolute'; host.style.left='-9999px'; host.style.top='-9999px';
        const kebab = toKebabCase(name);
        host.innerHTML = `<i data-lucide="${kebab}"></i>`;
        document.body.appendChild(host);
        // ask lucide to process just added node (it scans the document)
        window.lucide.createIcons();
        const svg = host.querySelector('svg');
        const out = svg ? svg.outerHTML : null;
        document.body.removeChild(host);
        return out;
      }catch(e){ return null; }
    }

    // Inline icon renderer using stored SVG markup, with Lucide fallback
    function renderIconInline(g, el, w, h){
      const svgFromString = (svgStr)=>{
        const str = (svgStr||'').trim(); if (!str) return false;
        // Parse as real SVG
        let root = null;
        try{
          const parser = new DOMParser();
          const doc = parser.parseFromString(str, 'image/svg+xml');
          root = doc.documentElement;
          if (!root || root.nodeName.toLowerCase() !== 'svg') return false;
        }catch(e){ return false; }
        const vb = root.getAttribute('viewBox') || '0 0 24 24';
        const parts = vb.split(' ').map(Number); const vbw = parts[2]||24, vbh = parts[3]||24;
        const sx = w / vbw, sy = h / vbh;
        const wrap = svgEl('g', { transform:`scale(${sx} ${sy})`, stroke:'#374151' });
        // import children
        Array.from(root.childNodes).forEach(node=>{
          if (node.nodeType !== 1) return;
          const tag = node.nodeName.toLowerCase();
          if (!['path','circle','rect','polygon','polyline','line','g'].includes(tag)) return;
          const attrs = Object.fromEntries(Array.from(node.attributes).map(a=>[a.name,a.value]));
          const n = svgEl(tag, attrs);
          if (n.getAttribute('fill') === 'currentColor') n.setAttribute('fill','#374151');
          if (n.getAttribute('stroke') === 'currentColor') n.setAttribute('stroke','#374151');
          wrap.appendChild(n);
        });
        g.appendChild(wrap); return true;
      };
      if (typeof el.iconSvg === 'string' && el.iconSvg.trim()) { if (svgFromString(el.iconSvg)) return; }
      if (el.lib==='lucide'){
        // Try direct API
        try{
          const pascal = toPascalCase(el.icon);
          if (window.lucide?.icons?.[pascal]){
            if (svgFromString(window.lucide.icons[pascal].toSvg({}))) return;
          }
        }catch(e){}
        // Fallback: dynamic replace trick
        const str = getLucideSvg(el.icon);
        if (str && svgFromString(str)) return;
      }
      // visible placeholder
      g.appendChild(svgEl('rect', { x:2, y:2, width:Math.max(0,w-4), height:Math.max(0,h-4), fill:'none', stroke:'#9ca3af', 'stroke-dasharray':'4,4' }));
    }

    function renderIconIntoGroup(g, el, w, h){
      if (el.lib === 'lucide' && window.lucide && window.lucide.icons && window.lucide.icons[el.icon]){
        try{
          const svgStr = window.lucide.icons[el.icon].toSvg({ stroke:'currentColor' });
          const temp = document.createElement('div'); temp.innerHTML = svgStr.trim();
          const svgNode = temp.firstChild; // <svg>
          const paths = Array.from(svgNode.querySelectorAll('path, circle, rect, polygon, polyline, line'));
          const vb = svgNode.getAttribute('viewBox') || '0 0 24 24';
          const [, , vbw, vbh] = vb.split(' ').map(Number);
          const sx = w / (vbw||24); const sy = h / (vbh||24);
          const wrap = svgEl('g', { transform:`scale(${sx} ${sy})` });
          for (const p of paths){
            const n = svgEl(p.tagName, Object.fromEntries(Array.from(p.attributes).map(a=>[a.name,a.value])));
            n.setAttribute('stroke', '#374151'); n.setAttribute('fill','none');
            wrap.appendChild(n);
          }
          g.appendChild(wrap);
          return;
        }catch(e){}
      }
      // Fallback (e.g., Bootstrap Icons via foreignObject)
      const fo = svgEl('foreignObject', { x:0, y:0, width:w, height:h, 'data-element-id': el.id });
      const div = document.createElement('div'); div.style.width='100%'; div.style.height='100%'; div.style.display='flex'; div.style.alignItems='center'; div.style.justifyContent='center';
      if (el.lib === 'bootstrap'){
        div.innerHTML = `<i class="bi bi-${el.icon}" style="font-size:${Math.min(w,h)*0.8}px; color:#374151;"></i>`;
      } else {
        div.textContent = el.icon || '?';
      }
      fo.appendChild(div); g.appendChild(fo);
    }

    function renderSVG(){
      const svg = $('#canvas');
      svg.innerHTML = '';

      svg.appendChild(svgEl('rect', { width:'100%', height:'100%', fill:'transparent', 'data-bg':'1' }));

      if (state.showGrid){
        const defs = svgEl('defs');
        const pat = svgEl('pattern', { id:'grid', width: state.gridSize, height: state.gridSize, patternUnits:'userSpaceOnUse' });
        const path = svgEl('path', { d:`M ${state.gridSize} 0 L 0 0 0 ${state.gridSize}`, fill:'none', stroke:'#ddd', 'stroke-width':'0.5', opacity:'0.8' });
        pat.appendChild(path);
        defs.appendChild(pat);
        svg.appendChild(defs);
        svg.appendChild(svgEl('rect', { width:'100%', height:'100%', fill:'url(#grid)'}));
      }

      for (const [i,g] of state.guideLines.entries()){
        if (g.type === 'vertical') svg.appendChild(svgEl('line', { x1:g.position, y1:0, x2:g.position, y2:'100%', stroke:g.color, 'stroke-width':1, 'stroke-dasharray':'5,5', opacity:.75, 'pointer-events':'none' }));
        else svg.appendChild(svgEl('line', { x1:0, y1:g.position, x2:'100%', y2:g.position, stroke:g.color, 'stroke-width':1, 'stroke-dasharray':'5,5', opacity:.75, 'pointer-events':'none' }));
      }

      const defs2 = svgEl('defs');
      const marker = svgEl('marker', { id:'arrowhead', markerWidth:10, markerHeight:7, refX:9, refY:3.5, orient:'auto' });
      marker.appendChild(svgEl('polygon', { points:'0 0, 10 3.5, 0 7', fill:'#374151' }));
      defs2.appendChild(marker);
      svg.appendChild(defs2);

      for (const conn of state.connections){
        const from = state.elements.find(e=>e.id===conn.from);
        const to = state.elements.find(e=>e.id===conn.to);
        if (!from || !to) continue;
        const fp = getConnectionPoints(from);
        const tp = getConnectionPoints(to);
        const dx = to.x - from.x; const dy = to.y - from.y;
        let start, end, d;
        if (conn.mode === 'horizontal'){
          start = fp.right; end = tp.left; d = `M ${start.x} ${start.y} L ${end.x} ${end.y}`;
        } else if (conn.mode === 'vertical'){
          start = fp.bottom; end = tp.top; d = `M ${start.x} ${start.y} L ${end.x} ${end.y}`;
        } else {
          if (Math.abs(dy) > Math.abs(dx)){
            if (dy > 0){ start = fp.bottom; end = tp.top; d = `M ${start.x} ${start.y} L ${end.x} ${start.y} L ${end.x} ${end.y}`; }
            else { start = fp.top; end = tp.bottom; d = `M ${start.x} ${start.y} L ${end.x} ${start.y} L ${end.x} ${end.y}`; }
          } else {
            if (dx > 0){ start = fp.right; end = tp.left; d = `M ${start.x} ${start.y} L ${start.x} ${end.y} L ${end.x} ${end.y}`; }
            else { start = fp.left; end = tp.right; d = `M ${start.x} ${start.y} L ${start.x} ${end.y} L ${end.x} ${end.y}`; }
          }
        }
        const g = svgEl('g');
        g.appendChild(svgEl('path', { d, stroke: conn.color || '#374151', 'stroke-width': 2, fill:'none', 'marker-end':'url(#arrowhead)', style:'cursor:pointer', 'data-connection-id': conn.id }));
        g.appendChild(svgEl('path', { d, stroke:'transparent', 'stroke-width': 8, fill:'none', style:'cursor:pointer', 'data-connection-id': conn.id }));
        svg.appendChild(g);
      }

      for (const el of state.elements){
        const w = el.width ?? 120, h = el.height ?? 60;
        const g = svgEl('g', { transform: `translate(${el.x}, ${el.y})` });
        const isSel = state.selectedElement===el.id || (state.selectedElements||[]).includes(el.id);
        const common = { fill: el.color, stroke: isSel? '#ef4444' : '#374151', 'stroke-width': isSel? 3 : 1, style:'cursor:move', 'data-element-id': el.id };

      switch ((elementTypes[el.type]?.shape)||'rectangle'){
        case 'oval': g.appendChild(svgEl('ellipse', { cx:w/2, cy:h/2, rx:w/2, ry:h/2, ...common })); break;
        case 'rectangle': g.appendChild(svgEl('rect', { width:w, height:h, rx:5, ...common })); break;
        case 'diamond': g.appendChild(svgEl('polygon', { points: `${w/2},0 ${w},${h/2} ${w/2},${h} 0,${h/2}`, ...common })); break;
        case 'document': {
          g.appendChild(svgEl('rect', { width:w, height:h-10, ...common }));
          g.appendChild(svgEl('path', { d:`M0,${h-10} Q${w/4},${h} ${w/2},${h-5} T${w},${h-10}`, ...common }));
          break; }
        case 'database': {
          g.appendChild(svgEl('ellipse', { cx:w/2, cy:10, rx:w/2, ry:10, ...common }));
          g.appendChild(svgEl('rect', { x:0, y:10, width:w, height:h-20, ...common }));
          g.appendChild(svgEl('ellipse', { cx:w/2, cy:h-10, rx:w/2, ry:10, ...common }));
          break; }
        case 'trapezoid': g.appendChild(svgEl('polygon', { points:`20,0 ${w-20},0 ${w},${h} 0,${h}`, ...common })); break;
        case 'delay': g.appendChild(svgEl('path', { d:`M0,0 L${w-20},0 Q${w},0 ${w},${h/2} Q${w},${h} ${w-20},${h} L0,${h} Z`, ...common })); break;
        case 'circle': { const r = Math.min(w,h)/4; g.appendChild(svgEl('circle', { cx:w/2, cy:h/2, r, ...common })); break; }
        case 'image': {
          // draw image then selection stroke frame
          const imgEl = document.createElementNS(NS, 'image');
          // data URLs or http(s) URLs
          if (el.src){
            try { imgEl.setAttributeNS('http://www.w3.org/1999/xlink','href', el.src); } catch(e){}
            imgEl.setAttribute('href', el.src);
          }
          imgEl.setAttribute('width', String(w));
          imgEl.setAttribute('height', String(h));
          imgEl.setAttribute('preserveAspectRatio','xMidYMid meet');
          imgEl.setAttribute('style','pointer-events:all');
          imgEl.setAttribute('data-element-id', el.id);
          g.appendChild(imgEl);
          g.appendChild(svgEl('rect', { width:w, height:h, fill:'none', stroke: state.selectedElement===el.id? '#ef4444' : '#374151', 'stroke-width': state.selectedElement===el.id? 3 : 1, 'pointer-events':'none' }));
          break; }
        case 'icon': {
          // First try vector paths for immediate visibility
          let shown = false;
          if (el.iconSvg) shown = renderSvgMarkupAsPaths(g, el.iconSvg, w, h);
          // Additionally render as raster PNG when available
          if (el.src){
            const imgEl = document.createElementNS(NS, 'image');
            try { imgEl.setAttributeNS('http://www.w3.org/1999/xlink','href', el.src); } catch(e){}
            imgEl.setAttribute('href', el.src);
            imgEl.setAttribute('width', String(w));
            imgEl.setAttribute('height', String(h));
            imgEl.setAttribute('preserveAspectRatio','xMidYMid meet');
            imgEl.setAttribute('style','pointer-events:all');
            imgEl.setAttribute('data-element-id', el.id);
            g.appendChild(imgEl);
            shown = true;
          } else if (el.iconSvg){
            // Kick off conversion; UI already shows vector paths
            svgToPngDataUrl(el.iconSvg, w, h).then(url=>{ if (url){ el.src = url; renderSVG(); } });
          }
          if (!shown){ g.appendChild(svgEl('rect', { width:w, height:h, rx:4, ry:4, fill:'#ffffff', stroke:'#9ca3af', 'stroke-dasharray':'4,4' })); }
          break; }
        default: g.appendChild(svgEl('rect', { width:w, height:h, ...common }));
      }

        if (state.selectedElement===el.id || state.connectionStart===el.id){
          const dot = (cx,cy)=>svgEl('circle',{ cx, cy, r:2, fill:'#10b981', 'fill-opacity':.5, stroke:'#fff', 'stroke-width':.5 });
          g.appendChild(dot(w/2, 0)); g.appendChild(dot(w/2, h)); g.appendChild(dot(0, h/2)); g.appendChild(dot(w, h/2));
        }

        if (state.selectedElement===el.id){
          const HANDLE_SIZE = 12;
          const HALF = HANDLE_SIZE/2;
          const handle = (x,y,cursor,name)=>svgEl('rect',{
            x, y, width: HANDLE_SIZE, height: HANDLE_SIZE,
            fill: '#ffffff', 'fill-opacity': 0.9,
            stroke: '#2563eb', 'stroke-width': 1.5,
            rx: 2, ry: 2,
            style:`cursor:${cursor}`,
            'data-element-id': el.id, 'data-resize-handle': name
          });
          g.appendChild(handle(-HALF, -HALF, 'nwse-resize','nw'));
          g.appendChild(handle(w-HALF, -HALF, 'nesw-resize','ne'));
          g.appendChild(handle(-HALF, h-HALF, 'nesw-resize','sw'));
          g.appendChild(handle(w-HALF, h-HALF, 'nwse-resize','se'));
        }

      if (state.connectionStart===el.id){
          g.appendChild(svgEl('rect', { x:-5, y:-5, width:w+10, height:h+10, fill:'none', stroke:'#10b981', 'stroke-width':3, 'stroke-dasharray':'5,5', rx:5 }));
        }

        g.appendChild(svgEl('text', { x:w/2, y: h/2 + (el.fontSize||12)/3, 'text-anchor':'middle', 'font-size': el.fontSize||12, 'font-family': el.font||'Arial', 'font-weight': el.bold? '700':'400', 'font-style': el.italic? 'italic':'normal', fill:'#fff', style:'pointer-events:none; user-select:none;' }, [ document.createTextNode(el.text||'') ]));

        if (state.selectedElement===el.id){
          const del = svgEl('circle', { cx: w-10, cy: 10, r: 8, fill: varColor('--danger'), style:'cursor:pointer', 'data-delete-id': el.id });
          g.appendChild(del);
        }
        svg.appendChild(g);
      }
      // Draw marquee selection rectangle on top
      if (state.isMarquee && state.marqueeRect){
        const r = state.marqueeRect;
        svg.appendChild(svgEl('rect', { x:r.x, y:r.y, width:r.w, height:r.h, fill:'#3b82f6', 'fill-opacity':0.08, stroke:'#2563eb', 'stroke-dasharray':'4,4', 'stroke-width':1, 'pointer-events':'none' }));
      }
    }

    function varColor(name){
      const el = document.createElement('span');
      el.style.color = `var(${name})`; document.body.appendChild(el);
      const color = getComputedStyle(el).color; document.body.removeChild(el); return color;
    }

    function renderProps(){
      const p = $('#props');
      const activeId = state.selectedElement ?? (state.selectedElements && state.selectedElements.length===1 ? state.selectedElements[0] : null);
      const el = state.elements.find(e=>e.id===activeId);
      if (!el){ p.style.display='none'; p.innerHTML=''; return; }
      p.style.display='block';
      p.innerHTML = `
        <div class="prop-grid">
          <input id="propText" type="text" value="${escapeHtml(el.text||'')}" placeholder="${i18n('propTextPlaceholder')}" />
          <label>W:<input id="propW" type="number" min="50" max="500" value="${el.width||120}"></label>
          <label>H:<input id="propH" type="number" min="30" max="300" value="${el.height||60}"></label>
          <input id="propColor" type="color" value="${el.color||'#3b82f6'}" style="width:32px;height:32px;" />
          <select id="propFont">${fonts.map(f=>`<option ${el.font===f?'selected':''} value="${f}">${f}</option>`).join('')}</select>
          <input id="propFontSize" type="number" min="8" max="48" value="${el.fontSize||12}">
          <button id="propBold" class="${el.bold? 'primary':'gray'}">B</button>
          <button id="propItalic" class="${el.italic? 'primary':'gray'}"><i>I</i></button>
          ${el.type==='image' ? '<button id="propImgReplace" class="gray">Bild wechseln</button>' : ''}
        </div>`;

      $('#propText').addEventListener('input', e=>{ el.text = e.target.value; renderSVG(); });
      $('#propW').addEventListener('input', e=>{ el.width = parseInt(e.target.value)||120; renderSVG(); });
      $('#propH').addEventListener('input', e=>{ el.height = parseInt(e.target.value)||60; renderSVG(); });
      $('#propColor').addEventListener('input', e=>{ el.color = e.target.value; renderSVG(); });
      $('#propFont').addEventListener('change', e=>{ el.font = e.target.value; renderSVG(); });
      $('#propFontSize').addEventListener('input', e=>{ el.fontSize = parseInt(e.target.value)||12; renderSVG(); });
      $('#propBold').addEventListener('click', ()=>{ el.bold = !el.bold; renderProps(); renderSVG(); });
      $('#propItalic').addEventListener('click', ()=>{ el.italic = !el.italic; renderProps(); renderSVG(); });
      const replaceBtn = document.getElementById('propImgReplace');
      if (replaceBtn){
        replaceBtn.addEventListener('click', ()=>{
          const inp = document.createElement('input');
          inp.type='file'; inp.accept='image/*';
          inp.onchange = ev=>{
            const file = ev.target.files?.[0]; if(!file) return;
            const fr = new FileReader();
            fr.onload = () => { el.src = fr.result; renderSVG(); };
            fr.readAsDataURL(file);
          };
          inp.click();
        });
      }
    }

    function renderAll(){
      renderColumnsBg();
      renderSVG();
      renderProps();
      updateToolbarStates();
      $('#connectHint').style.display = state.isConnecting ? 'block' : 'none';
      $('#connectHint').textContent = state.connectionStart ? i18n('connectHintTarget') : i18n('connectHintStart');
    }

    function updateToolbarStates(){
      $('#connectBtn').className = state.isConnecting ? 'success' : 'gray';
      $('#pasteBtn').disabled = !state.copiedElement;
      $('#gridToggle').className = state.showGrid ? 'primary' : 'gray';
      $('#guidesToggle').className = state.showGuides ? 'primary' : 'gray';
      $('#connectionMode').value = state.connectionMode;
      $('#gridSize').value = state.gridSize;
      const aiEl = $('#aiEnable'); if (aiEl) aiEl.checked = state.aiEnabled;
      const bar = $('#aiBar'); if (bar) bar.style.display = state.aiEnabled ? 'flex' : 'none';
      const aiBtn = $('#aiGenerateBtn'); if (aiBtn) aiBtn.disabled = !state.aiEnabled;
    }

    function setLanguage(lang) {
        state.lang = lang;
        document.documentElement.lang = lang;

        $$('[data-translate-key]').forEach(el => {
            const key = el.dataset.translateKey;
            const translation = i18n(key, el.textContent);
            // Handle nested elements like in the recommended option
            if (el.children.length > 0) {
              const textNode = Array.from(el.childNodes).find(node => node.nodeType === Node.TEXT_NODE);
              if(textNode) textNode.textContent = translation;
            } else {
              el.textContent = translation;
            }
        });
        $$('[data-translate-key-placeholder]').forEach(el => el.placeholder = i18n(el.dataset.translateKeyPlaceholder));
        $$('[data-translate-key-title]').forEach(el => el.title = i18n(el.dataset.translateKeyTitle));

        // Update parts of UI that are rendered dynamically
        renderElementButtons();
        renderColumnsBar();
        renderAll();
    }

    // ======= Actions =======
    function addElement(type){
      const cfg = elementTypes[type]; if (!cfg) return;
      if (type === 'image'){
        const input = document.getElementById('imgInput'); if(!input) return;
        input.onchange = ev=>{
          const file = ev.target.files?.[0]; if(!file) return;
          const fr = new FileReader();
          fr.onload = ()=>{
            const img = new Image(); img.onload = ()=>{
              const maxW = 240; const scale = Math.min(1, maxW / img.width);
              const el = {
                id: genId(), type:'image', src: fr.result,
                x: 100, y: 100, width: Math.max(60, Math.round(img.width*scale)), height: Math.max(40, Math.round(img.height*scale)),
                text: '', color: '#ffffff', font: state.currentFont, fontSize: state.currentFontSize, bold:false, italic:false, column:1
              };
              state.elements.push(el); state.selectedElement = el.id; renderAll();
            };
            img.src = fr.result;
          };
          fr.readAsDataURL(file);
          ev.target.value='';
        };
        input.click();
      } else {
        const el = {
          id: genId(), type,
          x: 100, y: 100, width: 120, height: 60,
          text: i18n(cfg.nameKey), color: state.currentColor || cfg.color,
          font: state.currentFont, fontSize: state.currentFontSize,
          bold:false, italic:false, column:1
        };
        state.elements.push(el);
        state.selectedElement = el.id;
        renderAll();
      }
    }

    function openIconPicker(){
      const modal = document.getElementById('iconModal');
      const grid = document.getElementById('iconGrid');
      const libSel = document.getElementById('iconLibrary');
      const search = document.getElementById('iconSearch');
      modal.style.display='flex';
      const renderList = ()=>{
        grid.innerHTML='';
        const lib = libSel.value;
        let names = [];
        if (lib==='lucide' && window.lucide && window.lucide.icons){ names = Object.keys(window.lucide.icons); }
        else if (lib==='bootstrap'){ names = ['alarm','archive','arrow-right','bag','bell','bookmark','calendar','camera','check','cloud','cpu','download','emoji-smile','envelope','eye','file-earmark','filter','flag','folder','gear','geo','graph-up','heart','house','image','inbox','info-circle','link','lock','menu-button','music-note','pen','people','phone','play','printer','search','shield','star','trash','upload','wifi']; }
        const q = search.value?.toLowerCase()||'';
        names = names.filter(n=> n.toLowerCase().includes(q)).slice(0,250);
        for (const name of names){
          const cell = document.createElement('div'); cell.className='cell';
          // Preview rendering: use HTML icons to avoid heavy SVG parsing for many items
          const previewWrap = document.createElement('div'); previewWrap.style.width='32px'; previewWrap.style.height='32px'; previewWrap.style.display='flex'; previewWrap.style.alignItems='center'; previewWrap.style.justifyContent='center';
          if (lib==='bootstrap'){
            previewWrap.innerHTML = `<i class="bi bi-${name}" style="font-size:20px;color:#374151;"></i>`;
          } else if (lib==='lucide'){
            const iTag = document.createElement('i'); iTag.setAttribute('data-lucide', toKebabCase(name)); previewWrap.appendChild(iTag);
          }
          const label = document.createElement('div'); label.style.fontSize='11px'; label.className='label'; label.textContent = name;
          cell.appendChild(previewWrap); cell.appendChild(label);
          cell.addEventListener('click', async ()=>{
            const newEl = { id: genId(), type:'icon', lib:lib, icon:(lib==='lucide'? toKebabCase(name): name), x:100, y:100, width: 48, height:48, text:'', color:'#ffffff', font: state.currentFont, fontSize: state.currentFontSize, bold:false, italic:false };
            try{
              if (lib==='lucide'){
                // Ensure preview is rendered before we read it
                try { if (window.lucide && typeof window.lucide.createIcons==='function') window.lucide.createIcons({ root: previewWrap }); } catch(e){}
                const svgNode = previewWrap.querySelector('svg');
                let s = svgNode ? svgNode.outerHTML : null;
                if (!s) s = getLucideSvg(name);
                const pascal = toPascalCase(name);
                if (!s && window.lucide?.icons?.[pascal]){ s = window.lucide.icons[pascal].toSvg({}); }
                if (s){ newEl.iconSvg = s; const png = await svgToPngDataUrl(s, newEl.width, newEl.height); if (png){ newEl.src = png; newEl.type='image'; } }
              } else if (lib==='bootstrap'){
                const url = `https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/icons/${name}.svg`;
                const resp = await fetch(url); if (resp.ok){ const s = await resp.text(); newEl.iconSvg = s; const png = await svgToPngDataUrl(s, newEl.width, newEl.height); if (png){ newEl.src = png; newEl.type='image'; } }
              }
            }catch(e){}
            state.elements.push(newEl); state.selectedElement = newEl.id; modal.style.display='none'; renderAll();
          });
          grid.appendChild(cell);
        }
        // Render lucide previews in bulk
        if (lib==='lucide' && window.lucide && typeof window.lucide.createIcons==='function'){
          window.lucide.createIcons();
        }
      };
      libSel.onchange = renderList; search.oninput = renderList; document.getElementById('iconClose').onclick = ()=>{ modal.style.display='none'; };
      renderList();
    }

    function deleteElement(id){
      state.elements = state.elements.filter(e=>e.id!==id);
      state.connections = state.connections.filter(c=>c.from!==id && c.to!==id);
      if (state.selectedElement===id) state.selectedElement = null;
      renderAll();
    }

    function copyElement(){
      if (!state.selectedElement) return;
      const el = state.elements.find(e=>e.id===state.selectedElement);
      if (el){ state.copiedElement = JSON.parse(JSON.stringify(el)); updateToolbarStates(); }
    }

    function pasteElement(){
      if (!state.copiedElement) return;
      const src = state.copiedElement;
      const el = { ...src, id: genId(), x: (src.x||0)+30, y:(src.y||0)+30 };
      state.elements.push(el); state.selectedElement = el.id; renderAll();
    }

    function saveProject(){
      const data = { elements: state.elements, connections: state.connections, columns: state.columns, version:'1.0', timestamp: new Date().toISOString() };
      const blob = new Blob([JSON.stringify(data,null,2)], { type:'application/json' });
      const url = URL.createObjectURL(blob); const a=document.createElement('a');
      a.href=url; a.download = `flowchart_${new Date().toISOString().slice(0,10)}.json`; a.click(); URL.revokeObjectURL(url);
    }

    function exportSVG(){
      const svg = $('#canvas').cloneNode(true);
      const ser = new XMLSerializer();
      const source = ser.serializeToString(svg);
      const blob = new Blob([source], { type:'image/svg+xml' });
      const url = URL.createObjectURL(blob); const a = document.createElement('a');
      a.href = url; a.download='flowchart.svg'; a.click(); URL.revokeObjectURL(url);
    }
    
    function resetCanvas() {
      if (confirm(i18n('confirmReset'))) {
      state.elements = [];
      state.connections = [];
      state.selectedElement = null;
      state.copiedElement = null;
      renderAll();
  }
}

    // ======= Event Wiring =======
    $('#langSwitch').addEventListener('change', e => setLanguage(e.target.value));
    $('#resetBtn').addEventListener('click', resetCanvas);
    $('#connectBtn').addEventListener('click', ()=>{ state.isConnecting = !state.isConnecting; state.connectionStart = null; renderAll(); });
    $('#connectionMode').addEventListener('change', e=>{ state.connectionMode = e.target.value; renderAll(); });
    $('#gridToggle').addEventListener('click', ()=>{ state.showGrid = !state.showGrid; renderAll(); });
    $('#guidesToggle').addEventListener('click', ()=>{ state.showGuides = !state.showGuides; renderAll(); });
    $('#gridSize').addEventListener('input', e=>{ state.gridSize = clamp(parseInt(e.target.value)||20, 10, 50); renderAll(); });
    $('#copyBtn').addEventListener('click', copyElement);
    $('#pasteBtn').addEventListener('click', pasteElement);
    $('#saveBtn').addEventListener('click', saveProject);
    $('#exportSvgBtn').addEventListener('click', exportSVG);
    $('#loadBtn').addEventListener('click', ()=> $('#fileInput').click());
    $('#fileInput').addEventListener('change', e=>{
      const f = e.target.files?.[0]; if (!f) return; const r = new FileReader();
      r.onload = ev=>{
        let data = null;
        try { data = JSON.parse(ev.target.result); }
        catch(err){ alert(i18n('alertLoadError')); console.error(err); return; }
        if (data && (Array.isArray(data.elements) || Array.isArray(data.connections))){
          // Use robust loader that normalizes fields and triggers renders
          applyFlowJson(data);
        } else {
          alert(i18n('alertInvalidFile'));
        }
      }; r.readAsText(f); e.target.value='';
    });

    const aiEnableEl = $('#aiEnable');
    if (aiEnableEl) aiEnableEl.addEventListener('change', ()=>{ state.aiEnabled = aiEnableEl.checked; updateToolbarStates(); });
    const addImgBtn = document.getElementById('addImgBtn');
    if (addImgBtn) addImgBtn.addEventListener('click', ()=> addElement('image'));
    const addIconBtn = document.getElementById('addIconBtn');
    if (addIconBtn) addIconBtn.addEventListener('click', openIconPicker);

    document.addEventListener('keydown', e=>{
      if (e.ctrlKey || e.metaKey){
        if (e.key === 'c'){ e.preventDefault(); copyElement(); }
        else if (e.key === 'v'){ e.preventDefault(); pasteElement(); }
        else if (e.key === 's'){ e.preventDefault(); saveProject(); }
      } else if (e.key === 'Delete' && state.selectedElement){ e.preventDefault(); deleteElement(state.selectedElement); }
    });

    let pointerCapturing = false;
    $('#canvas').addEventListener('pointerdown', e=>{
      const svg = $('#canvas');
      const pt = svg.createSVGPoint(); pt.x = e.clientX; pt.y = e.clientY;
      const ctm = svg.getScreenCTM(); const p = pt.matrixTransform(ctm.inverse());
      state.dragStart = { x: p.x, y: p.y };
      const target = e.target;
      const elId = target.getAttribute('data-element-id');
      const handle = target.getAttribute('data-resize-handle');
      const connId = target.getAttribute('data-connection-id');
      const isBg = target.hasAttribute('data-bg');

      if (connId){ e.stopPropagation(); state.connections = state.connections.filter(c=>c.id !== connId); renderAll(); return; }
      if (handle && elId){ state.isResizing = true; state.resizeHandle = handle; state.selectedElement = elId; renderAll(); return; }
      if (target.hasAttribute('data-delete-id')){ const id = target.getAttribute('data-delete-id'); deleteElement(id); return; }

      if (elId){
        if (state.isConnecting){
          if (!state.connectionStart){ state.connectionStart = elId; renderAll(); }
          else if (state.connectionStart !== elId){
            state.connections.push({ id: genId(), from: state.connectionStart, to: elId, color: '#374151', mode: state.connectionMode });
            state.connectionStart = null; renderAll();
          }
        } else {
          // SHIFT toggles membership in multi-selection
          if (e.shiftKey){
            const idx = state.selectedElements.indexOf(elId);
            if (idx >= 0) state.selectedElements.splice(idx,1); else state.selectedElements.push(elId);
            state.selectedElement = state.selectedElements.length === 1 ? state.selectedElements[0] : null;
            renderAll();
          } else if ((state.selectedElements||[]).includes(elId)){
            // start group drag
            state.isDraggingGroup = true;
            state.groupStartPos = new Map(state.selectedElements.map(id=>{
              const el = state.elements.find(x=>x.id===id); return [id,{x:el.x,y:el.y}];
            }));
            renderAll();
          } else {
            // single selection drag
            state.selectedElements = [elId];
            state.selectedElement = elId;
            state.isDragging = true; renderAll();
          }
        }
      } else if (isBg){
        // Start marquee selection
        state.selectedElement = null; state.connectionStart = null; state.isDragging = false; state.isResizing = false; state.resizeHandle = null; state.guideLines = [];
        state.isMarquee = true; state.marqueeRect = { x: p.x, y: p.y, w: 0, h: 0 };
        renderAll();
      }
      e.currentTarget.setPointerCapture(e.pointerId); pointerCapturing = true;
    });

    document.addEventListener('pointermove', e=>{
      if (!pointerCapturing) return; const svg = $('#canvas');
      const pt = svg.createSVGPoint(); pt.x = e.clientX; pt.y = e.clientY; const ctm = svg.getScreenCTM(); const p = pt.matrixTransform(ctm.inverse());
      const dx = p.x - state.dragStart.x; const dy = p.y - state.dragStart.y;

      if (state.isResizing && state.selectedElement && state.resizeHandle){
        const el = state.elements.find(x=>x.id===state.selectedElement); if (!el) return;
        let newX = el.x, newY = el.y; let newW = el.width||120, newH = el.height||60;
        switch (state.resizeHandle){
          case 'se': newW = Math.max(50, (el.width||120) + dx); newH = Math.max(30, (el.height||60) + dy); break;
          case 'sw': newW = Math.max(50, (el.width||120) - dx); newH = Math.max(30, (el.height||60) + dy); newX = el.x + dx; break;
          case 'ne': newW = Math.max(50, (el.width||120) + dx); newH = Math.max(30, (el.height||60) - dy); newY = el.y + dy; break;
          case 'nw': newW = Math.max(50, (el.width||120) - dx); newH = Math.max(30, (el.height||60) - dy); newX = el.x + dx; newY = el.y + dy; break;
        }
        // Show guides while resizing as well
        const dragged = { ...el, x:newX, y:newY, width:newW, height:newH };
        state.guideLines = generateGuideLines(dragged);
        el.x = newX; el.y = newY; el.width = newW; el.height = newH;
        state.dragStart = { x: p.x, y: p.y };
        renderSVG(); renderProps();
      } else if (state.isDraggingGroup && (state.selectedElements||[]).length){
        // move group based on stored start positions
        for (const id of state.selectedElements){
          const el = state.elements.find(x=>x.id===id); if (!el) continue;
          const start = state.groupStartPos?.get(id) || {x:el.x, y:el.y};
          el.x = snapToGrid(start.x + dx); el.y = snapToGrid(start.y + dy);
        }
        renderSVG();
      } else if (state.isMarquee && state.marqueeRect){
        const x1 = Math.min(state.dragStart.x, p.x), y1 = Math.min(state.dragStart.y, p.y);
        const x2 = Math.max(state.dragStart.x, p.x), y2 = Math.max(state.dragStart.y, p.y);
        state.marqueeRect = { x: x1, y: y1, w: x2-x1, h: y2-y1 };
        // update selection
        const sel = [];
        for (const el of state.elements){
          const w = el.width||120, h = el.height||60;
          const ex1 = el.x, ey1 = el.y, ex2 = el.x + w, ey2 = el.y + h;
          if (ex2 >= x1 && ex1 <= x2 && ey2 >= y1 && ey1 <= y2){ sel.push(el.id); }
        }
        state.selectedElements = sel; state.selectedElement = sel.length===1? sel[0] : null;
        renderSVG();
      } else if (state.isDragging && state.selectedElement){
        const el = state.elements.find(x=>x.id===state.selectedElement); if (!el) return;
        const newX = snapToGrid(el.x + dx); const newY = snapToGrid(el.y + dy);
        const dragged = { ...el, x:newX, y:newY };
        state.guideLines = generateGuideLines(dragged);
        el.x = newX; el.y = newY; state.dragStart = { x: p.x, y: p.y };
        renderSVG();
      }
    });

    document.addEventListener('pointerup', e=>{
      if (!pointerCapturing) return; pointerCapturing = false;
      const svg = $('#canvas'); try{ svg.releasePointerCapture(e.pointerId); }catch{}
      if (state.isMarquee && state.marqueeRect && state.marqueeRect.w < 2 && state.marqueeRect.h < 2){
        // tiny click on bg clears selection
        state.selectedElements = []; state.selectedElement = null;
      }
      state.isDragging = false; state.isDraggingGroup = false; state.isMarquee = false; state.marqueeRect = null; state.groupStartPos = null;
      state.isResizing = false; state.resizeHandle = null; state.guideLines = []; renderSVG();
    });

    // ======= AI Flow (LLM Integration) =======
    async function generateFlowFromAI(){
      const key = $('#aiKey')?.value?.trim() || '';
      const model = $('#aiModel')?.value || 'gpt-4o-mini';
      const input = $('#aiInput')?.value?.trim() || '';
      if(!input){ alert(i18n('alertAINoInput')); return; }
      if(!key){ alert(i18n('alertAINoKey')); return; }
      setStatus(i18n('statusAISending'));
      try{
        const prompt = buildAIPrompt(input);
        // NOTE: The OpenAI endpoint below is incorrect according to the latest API.
        // It should be '/v1/chat/completions'. I'm correcting it.
        const res = await fetch('https://api.openai.com/v1/chat/completions',{
          method:'POST',
          headers:{ 'Content-Type':'application/json', 'Authorization':`Bearer ${key}` },
          body: JSON.stringify({
            model,
            messages: [
              { role:'system', content: 'You are a precise JSON generator.' },
              { role:'user', content: prompt }
            ],
            max_tokens: 4000,
            temperature: 0,
            response_format: { type: "json_object" }
          })
        });
        const data = await res.json();
        if(!res.ok){ throw new Error(data?.error?.message || 'API Error'); }
        const text = data?.choices?.[0]?.message?.content || '{}';
        const json = extractJson(text);
        if(!json){ throw new Error('No valid JSON found in model output.'); }
        applyFlowJson(json);
        setStatus(i18n('statusAILoaded'));
      }catch(err){
        console.error(err);
        alert(i18n('alertGenericError') + err.message);
        setStatus(i18n('statusAIFailed'));
      }
    }

    function buildAIPrompt(orgText){
        return i18n('aiPrompt').replace('{orgText}', orgText);
    }

    function extractJson(s){
      try { return JSON.parse(s); } catch(e){}
      const start = s.indexOf('{'); const end = s.lastIndexOf('}');
      if(start !== -1 && end !== -1 && end > start){
        try{ return JSON.parse(s.slice(start, end+1)); }catch(e){}
      }
      return null;
    }

    function applyFlowJson(data){
      // Load columns: keep id, nameKey, customName, flex (including 0), color
      if (Array.isArray(data.columns) && data.columns.length){
        state.columns = data.columns.map((c,i)=>({
          id: (c.id ?? (i+1)),
          nameKey: c.nameKey ?? state.columns?.[i]?.nameKey,
          customName: (typeof c.customName === 'string' && c.customName.trim().length) ? c.customName : null,
          // Respect 0 and fractional values; fallback to 1 only if invalid
          flex: (Number.isFinite(Number(c.flex)) && Number(c.flex) >= 0) ? Number(c.flex) : 1,
          color: c.color || '#ffffff'
        }));
      }

      // Map of original -> new ids for connections
      const idMap = new Map();
      state.elements = (data.elements||[]).map((e,i)=>{
        const id = e.id && String(e.id).trim() ? String(e.id) : genId();
        idMap.set(e.id || id, id);
        const type = normalizeType(e.type);

        // Determine lane from e.lane or numeric e.column -> column name
        let lane = e.lane;
        if (!lane && (e.column != null)){
          const colById = state.columns.find(c=> String(c.id) === String(e.column));
          if (colById) lane = colById.customName ?? i18n(colById.nameKey);
          else {
            // try 1-based index
            const idx = Number(e.column) - 1;
            const c = state.columns[idx];
            if (c) lane = c.customName ?? i18n(c.nameKey);
          }
        }
        lane = lane || state.columns?.[0]?.customName || i18n(state.columns?.[0]?.nameKey || 'defaultColName');

        return {
          id, type,
          text: (typeof e.text === 'string' ? e.text : (elementTypes[type]?.nameKey ? i18n(elementTypes[type].nameKey) : i18n('defaultNodeName'))),
          color: e.color || elementTypes[type]?.color || '#3b82f6',
          font: e.font || state.currentFont,
          fontSize: Number.isFinite(Number(e.fontSize)) ? Number(e.fontSize) : state.currentFontSize,
          bold: !!e.bold,
          italic: !!e.italic,
          width: Number.isFinite(Number(e.width)) ? Number(e.width) : 120,
          height: Number.isFinite(Number(e.height)) ? Number(e.height) : 60,
          x: Number.isFinite(e.x) ? Number(e.x) : null,
          y: Number.isFinite(e.y) ? Number(e.y) : null,
          src: (typeof e.src === 'string' && e.src) ? e.src : undefined,
          lib: (typeof e.lib === 'string' && e.lib) ? e.lib : undefined,
          icon: (typeof e.icon === 'string' && e.icon) ? e.icon : undefined,
          iconSvg: (typeof e.iconSvg === 'string' && e.iconSvg) ? e.iconSvg : undefined,
          lane
        };
      });
      state.connections = (data.connections||[]).map(c=>({
        id: genId(), from: idMap.get(c.from) || c.from, to: idMap.get(c.to) || c.to, color:'#374151',
        mode: (c.mode==='horizontal'||c.mode==='vertical')? c.mode : 'auto'
      })).filter(c=>c.from && c.to);

      autoLayoutIfNeeded();
      state.selectedElement = null;
      // Rebuild the columns toolbar so its inputs bind to the new objects
      renderColumnsBar();
      renderAll();
      // Ensure paint after file load even if browser batches renders
      setTimeout(()=>renderAll(), 0);
    }

    function normalizeType(t){
      const s = String(t||'process').toLowerCase();
      if (s.includes('start') || s.includes('end')) return 'start';
      if (s.includes('decision') || s.includes('if') || s.includes('ja/nein') || s.includes('yes/no') || s.includes('diamond')) return 'decision';
      if (s.includes('doc')) return 'document';
      if (s.includes('data')) return 'database';
      if (s.includes('wait') || s.includes('delay')) return 'wait';
      if (s.includes('manual')) return 'manual';
      if (s.includes('image') || s.includes('img') || s.includes('bild')) return 'image';
      if (s.includes('connector') || s==='conn') return 'connector';
      return 'process';
    }

    function autoLayoutIfNeeded(){
      const needs = state.elements.some(e=>e.x==null || e.y==null);
      if(!needs) return;
      const laneMap = new Map();
      state.columns.forEach((c,idx)=> laneMap.set(c.customName ?? i18n(c.nameKey), idx));
      const colCount = Math.max(1,state.columns.filter(c=>c.flex>0).length);
      const colWidthPx = Math.max(240, (document.body.clientWidth/colCount) - 40);
      const topPad = 40; const leftPad = 40; const vGap = 30; const hGap = 60;
      const byLane = new Map();
      for(const e of state.elements){
        const laneName = e.lane && laneMap.has(e.lane) ? e.lane : (state.columns[0].customName ?? i18n(state.columns[0].nameKey));
        if(!byLane.has(laneName)) byLane.set(laneName, []);
        byLane.get(laneName).push(e);
      }
      for(const arr of byLane.values()){
        arr.sort((a,b)=>{
          const rank = t=> ({start:0, process:1, decision:2, document:3, database:3, manual:4, wait:5, connector:6}[t] ?? 10);
          return rank(a.type)-rank(b.type);
        });
      }
      for(const [lane, arr] of byLane){
        const colIdx = laneMap.get(lane) ?? 0;
        const baseX = leftPad + colIdx * (colWidthPx + hGap);
        let y = topPad;
        for(const e of arr){ e.x = baseX; e.y = y; y += (e.height||60) + vGap; }
      }
    }

    function setStatus(msg){ const s = document.querySelector('.status'); if(s) s.textContent = msg; }

    // ======= Init =======
    renderElementButtons();
    renderColumnsBar();
    setLanguage('de'); // Initialize with default language
    renderAll();
    // In rare cases first paint can be delayed; force a follow-up render next frame
    requestAnimationFrame(()=>renderAll());

    (function(){
      const bar = document.getElementById('aiBar');
      const btn = document.getElementById('aiGenerateBtn');
      const aiChk = document.getElementById('aiEnable');
      if (bar) bar.style.display = state.aiEnabled ? 'flex' : 'none';
      if (btn) btn.disabled = !state.aiEnabled;
      if (aiChk) aiChk.checked = state.aiEnabled;
    })();

    const aiGen = document.getElementById('aiGenerateBtn');
    if (aiGen) aiGen.addEventListener('click', generateFlowFromAI);
    const aiSample = document.getElementById('aiSampleBtn');
    if (aiSample) aiSample.addEventListener('click', ()=>{
      const t = document.getElementById('aiInput'); if(!t) return;
      t.value = i18n('aiSampleText');
    });

  </script>
  <!-- Icon libraries -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css">
  <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
</body>
</html>
